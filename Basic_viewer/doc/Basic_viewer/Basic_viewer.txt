namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Basic_viewer
\anchor ChapterBasicViewer

\author Guillaume Damiand, Mostafa Ashraf
\cgalAutoToc

\section Basic_Viewer

\subsection Introduction

The Basic_viewer class appears to serve as a foundation for a 3D graphics viewer in the context of the CGAL (Computational Geometry Algorithms Library) and Qt (a C++ GUI toolkit). The goal of Basic_viewer is to provide a flexible and interactive environment for visualizing geometric data and interacting with 3D scenes. The Functionality of the Basic_viewer is to renders various geometric elements such as(points, segments, rays, lines, faces, edges, etc.) and supports user interaction through keyboard inputs.

The goal of Basic_viewer is allowing to view all CGAL data structures, such as (Arrangement_on_surface_2, Boolean_set_operations_2, Linear_cell_complex, Nef_3, Periodic_2_triangulation_2, Point_set_3, Polygon, Polyhedron, Straight_skeleton_2, Surface_mesh, Triangulation_2, Triangulation_3, Voronoi_diagram_2, and more).

\subsubsection Some key goals and features of Basic_viewer include:

<OL>
<LI> Versatile Rendering:

The viewer supports the rendering of various geometric elements, such as points, edges, faces, rays, and lines.
Different rendering modes, including mono and colored representations, are available for these elements.

<LI> Camera Control:

The viewer allows users to switch between 2D and 3D viewing modes, adjusting the camera accordingly.
Camera settings, such as orthographic or perspective projection, can be configured based on the dimensionality of the scene.

<LI> User Interaction:

Users can interact with the viewer through keyboard inputs, enabling them to control rendering options, toggle the display of elements, and adjust visual parameters.
Key presses are mapped to specific actions, such as toggling the clipping plane, changing rendering modes, adjusting the size of elements, and modifying ambient light color.

<LI> Clipping Plane:

The viewer includes support for a clipping plane, allowing users to selectively render parts of the scene.
The clipping plane can be toggled on and off, and its rendering style can be modified (solid, wireframe, etc.).

<LI> Shader Support:

Shaders are compiled to enhance the rendering capabilities of the viewer, potentially providing advanced shading and visual effects.

<LI> Flexibility and Configurability:

The viewer is designed to be flexible, allowing users to configure various rendering parameters and interact with the scene based on their needs.
The code includes functions for setting up the initial state of the viewer, initializing OpenGL settings, and handling key events.

</OL>

Based on class QApplication_and_basic_viewer you can develop your own demo.

\subsection Basic_viewerUsage Basic Viewer Class Draw virtual function

The draw function is a virtual function in the Basic_viewer class responsible for rendering 3D elements such as points, segments, triangles, rays, lines, and faces. It utilizes OpenGL for rendering and incorporates several customization options for drawing styles and colors. Below is an overview of key functionalities:

<OL>
<LI> Initialization: The function starts by enabling depth testing and initializing matrices for the clipping plane.

<LI> Vertex Rendering: Renders vertices (points) based on specified rendering modes and colors. Supports both mono and colored points.

<LI> Edge Rendering: Renders edges (segments) with specified rendering modes and colors. Supports both mono and colored edges.

<LI> Ray Rendering: Renders rays with specified rendering modes and colors. Supports both mono and colored rays.

<LI> Line Rendering: Renders lines with specified rendering modes and colors. Supports both mono and colored lines.

<LI> Face Rendering: Renders faces (triangles) with specified rendering modes and colors. Supports both mono and colored faces. Implements transparency for specific rendering modes.

<LI> Clipping Plane Rendering: Renders the clipping plane when applicable.

<LI> Text Rendering: Renders text on the screen at specified positions.

<LI> Coordinate System Transformation: Applies transformations to bring drawings into the frame coordinate system. This includes multiplying matrices and scaling down drawings.

<LI> Additional Rendering Considerations: Handles Z-fighting by offsetting polygons and includes adjustments for two-dimensional rendering.
</OL>

\subsection Basic_viewerExamples Examples that use Basic_viewer

\subsubsection Basic_viewerExamples_simple_draw Basic draw

\cgalExample{Surface_mesh/draw_surface_mesh.cpp}

\subsubsection Basic_viewerExamples_custom_color Change Face Colors

\cgalExample{Basic_viewer/draw_surface_mesh_height.cpp}

\subsubsection Basic_viewerExamples_two_ds Draw two different CGAL data-structures in a same viewer

\cgalExample{Basic_viewer/draw_mesh_and_points.cpp}

\subsubsection Basic_viewerExamples_interact Interaction with the viewer

\cgalExample{Basic_viewer/draw_surface_mesh_small_faces.cpp}

\subsubsection Basic_viewerExamples_several_window Draw several basic viewers

\cgalExample{Basic_viewer/draw_several_windows.cpp}

\section  Graphic_Scene

The Graphics_scene class appears to be a container class responsible for managing CGAL data structures and handling buffers for various geometric elements, such as points, segments, rays, lines, and faces by fill data in given graphic buffer.

\subsection GraphicSceneClass key components and functionality of this class:
<OL>

<LI> Buffer Management:

<OL>
<LI> The class manages buffers for different geometric elements, including mono and colored versions of points, segments, rays, lines, and faces.
<LI> Buffers are stored in the arrays array, which holds vectors of BufferType (defaulted to float), and each buffer is initialized in the constructor.
</OL>

<LI> Bounding Box:
<OL>
<LI> The class maintains a bounding box (m_bounding_box) that encompasses all the geometric elements in the scene.
<LI> The bounding box can be initiated and updated based on the elements added to the scene.
</OL>

<LI> Adding Geometric Elements:
<OL>
<LI> The class provides template member functions (add_point, add_segment, add_ray, etc.) for adding various geometric elements to the corresponding buffers.
<LI> It supports both mono and colored versions of these elements, allowing for the addition of color information.
</OL>

<LI> Face Handling:
<OL>
<LI> The class supports the creation of faces by providing methods such as face_begin, add_point_in_face, and face_end.
<LI> Faces can be either mono or colored, and they are constructed by adding points to the corresponding face buffers.
</OL>

<LI> Normal Handling:
<OL>
<LI> Normals for faces are handled separately for smooth and flat shading, and they are part of the normal buffers.
</OL>

<LI> Text Handling:
<OL>
<LI> The class maintains a vector of text elements (m_texts), where each text element is associated with a 3D point in the scene.
<LI> Text elements can be added using the add_text member function.
</OL>

<LI> Utility Functions:
<OL>
<LI> The class provides utility functions such as checking if a face has started (a_face_started), clearing all buffers (clear), and determining if the scene is empty.
</OL>

<LI> Coordinate System Information:
<OL>
<LI> The class contains functions to check if the data structure lies on a particular plane (XY, XZ, or YZ), providing information about the coordinate system.
</OL>

<LI> Local Coordinate Transformations:
<OL>
<LI> There are template functions (get_local_point and get_local_vector) for transforming CGAL points and vectors into a local coordinate system (Local_kernel).
</OL>

<LI> Size and Dimensionality:
<OL>
<LI> Functions like get_size_of_index and number_of_elements provide information about the size and dimensionality of buffers.
</OL>

<LI> Miscellaneous:
<OL>
<LI> The class allows for reversing all normals in the scene using the reverse_all_normals function.
<LI> The empty function checks whether the scene is empty.
<LI> Functions like has_zero_x, has_zero_y, and has_zero_z check if any element in the scene has a zero value in a specific coordinate.
</OL>

</OL>

This class provides a comprehensive interface for managing and manipulating geometric data in a 3D scene, facilitating the rendering and interaction of complex scenes in a graphics application.


\subsection GraphicSceneContinue Graphics_scene_options
The Graphics_scene_options class is responsible for providing a set of options and customization parameters for rendering geometric structures in a graphics scene. Its main purpose is to allow users to control the visual appearance of various elements such as vertices, edges, faces, and volumes in a graphical representation of a combinatorial data structure (DS). The classes are template classes, allowing them to work with different combinatorial data structures (DS) in 2D and 3D.
\subsubsection GraphicSceneOptionsCont Here are some key responsibilities of the Graphics_scene_options class:
<OL>

<LI> Drawing Control: It determines whether to draw vertices, edges, faces, and volumes in the graphics scene through the use of drawing functors (draw_vertex, draw_edge, draw_face, draw_volume).

<LI> Coloring Control: It allows users to customize the coloring of vertices, edges, faces, and volumes. Users can specify whether coloring is enabled (colored_vertex, colored_edge, colored_face, colored_volume) and, if so, provide functions (vertex_color, edge_color, face_color, volume_color) to determine the color for each element.

<LI> Wireframe Control: For faces and volumes, it provides options to draw a wireframe representation (face_wireframe, volume_wireframe), allowing users to choose whether to display a wireframe overlay.

<LI> Visibility Control: Users can enable or disable the visibility of vertices, edges, faces, and volumes independently using functions like disable_vertices, enable_vertices, are_vertices_enabled, and similar functions for other components.

<LI> Template Flexibility: The class is templated to support different types of combinatorial data structures (DS) in 2D and 3D. This template flexibility allows users to use the class with various geometric structures.

<LI> Default Settings: It provides reasonable default settings for the various options, ensuring that users can get started with a sensible configuration without needing to customize every parameter.

</OL>

\section SoftwareDesignClassDiagam Software Design

The diagram in \cgalFigureRef{fig_basic_viewer_diagramme_class} shows the different classes of the package.

\cgalFigureBegin{fig_basic_viewer_diagramme_class,basic_viewer_diagramme_class.svg}
UML diagram of the main classes of the package.
\cgalFigureEnd

\section DrawFunction Global Draw Function

The draw function is a template function that facilitates drawing an almost mentioned data structures such as (Arrangement_on_surface_2, Boolean_set_operations_2, Linear_cell_complex, Nef_3, Periodic_2_triangulation_2, Point_set_3, Polygon, Polyhedron, Straight_skeleton_2, Surface_mesh, Triangulation_2, Triangulation_3, Voronoi_diagram_2, and more) in a graphics scene. It has two specialization, one for using graphics scene options and another without graphics scene options.

The draw function can be used in default way or in custom way with a graphics scene options

```
// Specialization of draw function for a LCC, with a drawing graphics scene options.
template<unsigned int d_, unsigned int ambient_dim, class Traits_,
         class Items_, class Alloc_,
         template <unsigned int, class, class, class, class> class Map,
         class Refs, class Storage_,
         class GSOptions>
void draw(const CGAL_LCC_TYPE& alcc, const GSOptions& gso,
          const char *title="LCC Basic Viewer")
{
  CGAL::Graphics_scene buffer;
  add_to_graphics_scene(alcc, buffer, gso);
  draw_graphics_scene(buffer, title);
}

// Specialization of draw function for a LCC, without a graphics scene options.
template<unsigned int d_, unsigned int ambient_dim, class Traits_,
         class Items_, class Alloc_,
         template <unsigned int, class, class, class, class> class Map,
         class Refs, class Storage_>
void draw(const CGAL_LCC_TYPE& alcc, const char *title="LCC Basic Viewer")
{
  CGAL::Graphics_scene buffer;
  add_to_graphics_scene(alcc, buffer);
  draw_graphics_scene(buffer, title);
}

```
As shown above in code snippt the add_to_graphics_scene function fill LCC in the given graphic buffer with or without options, and then we pass graphic buffer to draw_graphics_scene function which is designed to display or render the contents of a Graphics_scene object.

\cgalFigureBegin{linear_cell_complex_for_combinatorial_map_ex1,lcc_cmap_with_faces.png}
example of drawing LCC for CMap with faces
\cgalFigureEnd

\cgalFigureBegin{linear_cell_complex_for_combinatorial_map_ex2,lcc_cmap_without_edges.png}
example of drawing LCC for CMap without edges
\cgalFigureEnd

\cgalFigureBegin{linear_cell_complex_for_combinatorial_map_ex3,lcc_cmap_without_faces.png}
example of drawing LCC for CMap without faces
\cgalFigureEnd

*/

} /* namespace CGAL */

